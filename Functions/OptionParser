#!/bin/bash (source)

Import String
Import Process

declare -a savedOptions
#declare -a optionsShortList
#declare -a optionsLongList
#declare -a optionsDescriptionList
#declare -a optionsTypeList
#declare -a optionsStateList
optionsListSize=0
argumentsListSize=0
parsedArguments=0

function Add_Option() {
   local i
   if [ "$scriptDebug" = "on" ]
   then
      for i in `seq $optionsListSize`
      do
         if [ "$3" = "${optionsShortList[i]}" -o "$4" = "${optionsLongList[i]}" ]
         then Die "Script internal error: option name -$3 --$4 conflicts with -${optionsShortList[i]} --${optionsLongList[i]}."
         fi
      done
   fi
   optionsListSize=$[optionsListSize+1]
   optionsTypeList[$optionsListSize]="$1"
   optionsStateList[$optionsListSize]="$2"
   optionsShortList[$optionsListSize]="$3"
   optionsLongList[$optionsListSize]="$4"
   optionsDescriptionList[$optionsListSize]="$5"
}

function Add_Option_Boolean() {
   Add_Option "Boolean" "" "$@"
}

function Add_Option_Entry() {
   if [ "$4" ]
   then Add_Option "Entry" "$4" "$1" "$2" "$3"
   else Add_Option "Entry" "#@unset@#" "$1" "$2" "$3"
   fi 
}

function Add_Option_List() {
   if [ "$4" ]
   then Add_Option "List" "$4" "$1" "$2" "$3"
   else Add_Option "List" "#@unset@#" "$1" "$2" "$3"
   fi 
}

function Add_Argument() {
   argumentsList[$argumentsListSize]="$1"
   argumentsListSize=$[argumentsListSize+1]
}

# Usage:   eval `Args_To_Array <array_name> [<from> [<to>]]`
# Example: eval `Args_To_Array myArray 5`
#          Returns an array called myArray containing Args 5 and up.
# Example: eval `Args_To_Array myArray`
#          Returns an array called myArray with all non-option arguments.
function Args_To_Array() {
   name="$1"
   if [ "$2" ]
   then start="$2"
   else start=1
   fi
   if [ "$3" ]
   then length="$3"
   else length=$[argumentsListSize-1]
   fi
   echo -n "$name=("
   for (( i=$start ; i<=$length ; i++ ))
   do
      echo -n "\"${argumentsList[$i]}\" "
   done
   echo ")"
}

function Arg() {
   if [ -z "$1" ]
   then Die "You need to specify which argument"
   fi
   if [ $1 -lt 0 ] || [ $1 -ge $argumentsListSize ]
   then echo ""
   else echo "${argumentsList[$1]}"
   fi
}

function Number_Of_Arguments() {
   # $0 isn't considered an argument
   echo $[$argumentsListSize-1]
}

function Entry() {
   local i
   for i in `seq $optionsListSize`
   do
      if [ "$1" = "${optionsShortList[i]}" -o "$1" = "${optionsLongList[i]}" ]
      then
         value="${optionsStateList[i]}"
         if [ "$value" = "#@unset@#" ]
         then return 1
         else
            echo "$value"
            return 0
         fi
      fi
   done
   return 2
}

function Is_Entry_Set() {
   Quiet Entry "$@"
}

function Is_Entry() {
   Parameters "$@" option compare
   local i
   if Is_Empty "$compare"
   then
      Quiet Entry "$1"
      return $?
   fi

   for i in `seq $optionsListSize`
   do
      if [ "$option" = "${optionsShortList[i]}" -o "$option" = "${optionsLongList[i]}" ]
      then
         value="${optionsStateList[i]}"
         if [ "$value" = "$compare" ]
         then return 0
         else return 1
         fi
      fi
   done
   return 2
}

# detsch, 23/08/2004
# experimental, should be a more generic function
function Forward_Boolean_Entry() {
   if Boolean "$1"
   then
      echo "--$1"
   else
      echo ""
   fi
}

function Boolean() {
   local i
   for i in `seq $optionsListSize`
   do
      if [ "$1" = "${optionsShortList[i]}" -o "$1" = "${optionsLongList[i]}" ]
      then
         if [ "${optionsStateList[i]}" = "on" ]
         then return 0
         else return 1
         fi
      fi
   done
   return 2
}

function Set_Boolean() {
   local i
   for i in `seq $optionsListSize`
   do
      if [ "$1" = "${optionsShortList[i]}" -o "$1" = "${optionsLongList[i]}" ]
      then
         if [ "$2" ]
         then optionsStateList[i]="$2"
         else optionsStateList[i]="on"
         fi
         return 0
      fi
   done
   return 2
}

function Show_Version() {
   echo "$scriptName $scriptVersion"
   echo
   [ "$scriptCredits" ] && echo "$scriptCredits"
   exit 0
}

function Show_Help() {
   {
      local i
      if [ "$HELP2MAN" ]
      then
         local H2Mn=-n
         local H2Mecho=echo
      else
         local H2Mecho=:
         local H2Mtab="    "
         local H2Mnotes="Notes:"
      fi
      [ "$scriptDescription" ] && echo "$scriptDescription"
      echo
      echo -e "Usage: $scriptName $scriptUsage"
      echo
      echo "Options:"
      for i in `seq $optionsListSize`
      do
         echo -n "   "
         if [ ! -z "${optionsShortList[i]}" ]
         then
            echo -n " -${optionsShortList[i]}"
         fi
         if [ ! -z "${optionsShortList[i]}" -a ! -z "${optionsLongList[i]}" ]
         then
            echo -n ","
         fi
         if [ ! -z "${optionsLongList[i]}" ]
         then
            echo -n " --${optionsLongList[i]}"
         fi
         case "${optionsTypeList[i]}" in
         "Entry")
            echo $H2Mn " <entry>"
            echo -e "        ${optionsDescriptionList[i]}"
            if [ "${optionsStateList[i]}" != "#@unset@#" ]
            then
               echo "        The default value is '${optionsStateList[i]}'."
            fi
            $H2Mecho
            ;;
         "List")
            echo $H2Mn " <entry>[:<entry>...]"
            echo -e "        ${optionsDescriptionList[i]}"
            if [ "${optionsStateList[i]}" != "#@unset@#" ]
            then
               echo "        The default value is '${optionsStateList[i]}'."
            fi
            $H2Mecho
            ;;
         "Boolean")
            echo $H2Mn ""
            echo -e "        ${optionsDescriptionList[i]}"
            $H2Mecho
            ;;
         esac # esac is ridiculous.
      done
      echo
      if [ "$scriptNotes" ]
      then
         echo "$H2Mnotes"
         echo "$H2Mtab$scriptNotes"
         echo
      fi
      if [ "$scriptExample" ]
      then
         echo "Examples:"
         $H2Mecho
         echo -e "$scriptExample" | while read line; do echo -e "$H2Mtab$scriptName $line"; done
         echo
      fi
   } | fmt -sw "$COLUMNS"
   exit 0
}

function List_Options() {
   local i
   for ((i=1; i <= optionsListSize; i++))
   do
      echo -n "-${optionsShortList[i]} --${optionsLongList[i]} "
   done
   echo
   exit 0
}

function Parse_Options() {
   Add_Argument "$0"

   if [ "$helpOnNoArguments" -a -z "$*" ]
   then Show_Help
   fi

   savedOptions=("$@")
   # loop through all arguments
   for (( i = 1; i <= $# ; i++ ))
   do
      eval option=\${${i}}
      unknownOption=true
      if [ "${option:0:1}" = "-" ]
      then # we have an option
         if [ "${option:1:1}" = "-" ]
         then # a double dash so it should be a long option
            if [ -z "${option:2:1}" ]
            then
               # it's a lonely double dash '--'.
               # Consume all and stop parsing.
               for (( j = i+1; j <= $# ; j++ ))
               do
                  eval option=\${${j}}
                  Add_Argument "$option"
               done
               break
            fi
            if echo "$option" | grep -q = -
            then
               # argument assignment with =
               opt=`echo $option | cut -d= -f1`
            else
               opt=`echo $option | cut -d' ' -f1`
            fi
            export parsedArguments=$[parsedArguments+1]

            # Go through the list of available options
            for j in `seq $optionsListSize`
            do
               if [ "$opt" = "--${optionsLongList[j]}" ]
               then
                  # we found a valid (known) option
                  unknownOption=false
                  case "${optionsTypeList[j]}" in
                  "Boolean")
                     optionsStateList[j]="on"
                     ;;
                  "Entry"|"List")
                     if echo "$option" | grep -q = -
                     then
                        # long option value assignment with =
                        val=`echo $option | cut -d= -f2`
                     else
                        # else use next argument as value for the option
                        i=$[i+1]
                        eval val=\$$i
                        export parsedArguments=$[parsedArguments+1]
                     fi
                     if [ -z "$val" ]
                     then
                        # we reached the end of the line without finding a value to assign
                        Log_Error "Unknown option: $opt requires an argument."
                        Show_Help
                        exit 1
                     fi
                     optionsStateList[j]="$val"
                     ;;
                  esac
                  break
               fi
            done
            if $unknownOption
            then
               Log_Error "Unknown option: $opt"
               exit 1
            fi
         else # double dash
            # go through the string of short options
            for (( k = 1; k < ${#option} ; k++ ))
            do
               opt=${option:$k:1} # the character number k in the string
               for j in `seq $optionsListSize`
               do
                  if [ "$opt" = "${optionsShortList[j]}" ]
                  then
                     # we found a valid (known) option
                     unknownOption=false
                     case "${optionsTypeList[j]}" in
                     "Boolean")
                        optionsStateList[j]="on"
                        break
                        ;;
                     "Entry"|"List")
                        if [ ! -z "${option:$[k+1]:1}" ]
                        then
                           # if option is entry and next character in string isn't empty
                           # use the rest of the string as value for the option
                           val=${option:$[k+1]:${#option}}
                        else
                           # else use next option as value
                           i=$[i+1]
                           eval val=\$$i
                           export parsedArguments=$[parsedArguments+1]
                        fi
                        if [ -z "$val" ]
                        then
                           # we didn't find any value to assign, so we die
                           Log_Error "Unknown option: $opt requires an argument."
                           Show_Help
                           exit 1
                        fi
                        optionsStateList[j]="$val"
                        break 2
                        ;;
                     esac
                  fi
               done
               if $unknownOption
               then
                  Log_Error "Unknown option: -$opt"
                  exit 1
               fi
            done
            export parsedArguments=$[parsedArguments+1]
         fi
      else # dash found
         Add_Argument "$option"
      fi
   done
   if Boolean "help"
   then Show_Help
   fi
   if Boolean "version"
   then Show_Version
   fi
   if Boolean "list-options"
   then List_Options
   fi
   if Boolean "verbose"
   then Import LogVerbose
   fi
}

Add_Option_Boolean "h" "help" "Shows this help."
Add_Option_Boolean "" "version" "Show program version."
Add_Option_Boolean "v" "verbose" "Enable verbose mode."
