#!/bin/sh

### Imports ###################################################################

source ScriptFunctions
Import Array
Import File
Import GoboLinux
Import Log
Import OptionParser
Import Process

### Options ###################################################################

scriptDescription="Run the program in a protected sandbox, as superuser, using unionfs"
scriptCredits="Copyright (C) 2003. Released under the GNU GPL."
helpOnNoArguments=yes
scriptUsage="[<options>] <program> [<command-parameters...>]"
scriptExample="-r 0.0 -s '.:${goboPrograms}/NaughtyApp/Current' make install"
scriptNotes="
To allow mobility within the sandbox, the '.' directory is mounted at
a sandbox root (like $sandboxroot). For this reason, use of relative paths like '..' to reach
directories higher in the hierarchy than '.' may produce unexpected results.
It may also confuse symbolic links that flow through the sandbox.
"

# Are these used anymore?  They're not used by SandboxInstall
#Add_Option_Boolean "o" "original" "Restore original owners."
#Add_Option_Entry "r" "restore" "Restore ownership to <entry>."

Add_Option_Entry "w" "writedir" "The dir where writes outside sandbox are written."
Add_Option_Entry "d" "directory" "The program should be run at <entry>. "\
"This path should be either absolute, or relative to the sandbox root."
Add_Option_List "s" "sandbox" "Colon-separated list of areas where the restricted process has write access to." "."
Add_Option_List "m" "map" "Colon-separated mapping (lhs=rhs) where writes to rhs are mapped to lhs." ""
Parse_Options "$@"
shift $parsedArguments

Parse_Conf Directories.conf

### Operation #################################################################
Verify_Superuser

[ "$1" ] || Die "Please specify a command to be executed inside the sandbox."
[ `cat $goboStatus/filesystems | grep unionfs |wc -l` = "0" ] && Die "unionfs is unavailabe on this system."

[ "${unionSandbox[0]}" = "" ] && Die "Please set unionSandbox in Settings/Scripts/Directories.conf"
[ "$unionSandboxMP" = "" ] && Die "Please set unionSandboxMP in Settings/Scripts/Directories.conf"
[ "$unionSandboxRW" = "" ] && Die "Please set unionSandboxRW in Settings/Scripts/Directories.conf"

sandbox_mp=`mktemp -d "${unionSandboxMP}.tmp.XXXXXXXXXXX"`
sandbox_rw=`mktemp -d "${unionSandboxRW}.tmp.XXXXXXXXXXX"`

function RealPath {
    readlink -f $@
}

List_To_Array "sandbox" bindmounts
bindmounts=(`Map RealPath "${bindmounts[@]}"`)
List_To_Array "map" mapmounts

# Preset cmd status
result=0

# Called at end of script and by signal handler
function cleanup() {
    Log_Normal "Cleaning up."
#    Log_Verbose "Undoing the sandbox..."

    # Unmount everythin under $sandbox_mp
    cat $goboStatus/mounts |tac |cut -d' ' -f2 |grep $sandbox_mp | \
    while read mp
    do
        umount $mp
    done

    # Clean up unionfs mountpoints
    For_Each unionSandbox 'rmdir ${sandbox_mp}${each}
        Quiet rmdir ${sandbox_rw}${each} '

    # Clean up legacy links
    rm -rf ${sandbox_mp}/usr
    rm  ${sandbox_mp}/bin ${sandbox_mp}/dev ${sandbox_mp}/etc 
    rm  ${sandbox_mp}/lib ${sandbox_mp}/proc ${sandbox_mp}/sbin 
    rm  ${sandbox_mp}/sys ${sandbox_mp}/tmp ${sandbox_mp}/var 

    # Remove tmp dirs
    if Is_Entry_Set "writedir"
    then
	writedir=`Entry "writedir"`
	Log_Normal "Moving entries to: $writedir"
	Assert_Dir $writedir
	cp -ra "$sandbox_rw/." "$writedir"
	Quiet mv $sandbox_mp/* $writedir
    fi
    rm -rf $sandbox_rw
    rmdir $sandbox_mp

    exit $result
}
function sandbox_die() {
    message=$1
    Log_Error $message
    result=1
    cleanup
}

function mount_union() {
    dir=$1
    Assert_Dir ${sandbox_mp}${dir}
    Assert_Dir ${sandbox_rw}${dir}
	[ ! -h ${goboDevices}/root ] && ln -s / ${goboDevices}/root
    mount -t unionfs -o dirs=${sandbox_rw}${dir}=rw:${dir}=ro none ${sandbox_mp}${dir}
    [ "$?" = "0" ] || sandbox_die "Unable to mount unionfs"
}

trap "sandbox_die 'Interrupted...'" SIGHUP SIGINT SIGTERM

Log_Verbose "Preparing the sandbox..."

# Mount unionfs
For_Each unionSandbox 'mount_union $each'

# Bind mount writable areas
error=false
For_Each bindmounts 'mount -o bind $each ${sandbox_mp}/${each}; [ "$?" = "0" ] || error=true'
[ "$error" = "false" ] || sandbox_die "Unable to mount writable areas in chroot"

error=false
For_Each mapmounts 'lhs=$(readlink -f `echo $each | cut -d= -f1`)
    rhs=$(readlink -f `echo $each | cut -d= -f2`)
    Assert_Dir $rhs
    mount -o bind $lhs ${sandbox_mp}/$rhs 
    [ "$?" = "0" ] || error=true
    '
[ "$error" = "false" ] || sandbox_die "Unable to mount map areas in chroot"

# Create legacy links
cp -ar /usr "$sandbox_mp"
cp -a /bin /dev /etc /lib /proc /sbin /sys /tmp /var "$sandbox_mp"

# Create wrapper
newpwd="$PWD"
Is_Entry_Set "directory" && newpwd=`Entry "directory"`
echo "#!/bin/sh" >"${sandbox_mp}/.wrapper"
echo "cd $newpwd" >>"${sandbox_mp}/.wrapper"
echo "exec $@" >>"${sandbox_mp}/.wrapper"

chmod a+x "${sandbox_mp}/.wrapper"


# Run program in chrooted sandbox
chroot $sandbox_mp /.wrapper
result=$?

# Remove wrapper
rm "$sandbox_mp/.wrapper"

# Postprocess $sandbox_rw


# Cleanup
cleanup

