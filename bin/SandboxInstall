#!/bin/sh

source ScriptFunctions
Import File
Import GoboLinux
Import OptionParser
Import Process
Import String
Import Directories

helpOnNoArguments=yes
scriptDescription="Runs 'make install', using a sandbox environment."
scriptCredits="Copyright (C) Hisham Muhammad, 2001-2005 - Released under the GNU GPL."
scriptUsage="[<options>] <program_name> <program_version> [ -- <extra_arguments> ]"
scriptExample="--makefile makefile.unix --target install_shared WeirdSuperLib 2.4"
scriptNotes="
Normally you'll want to use Compile(1) instead.
'$scriptName' is called by Compile(1).
"
Add_Option_Entry "t" "target" "Makefile target to be used." "install"
Add_Option_Entry "f" "makefile" "Specify which makefile to use." "Makefile"
Add_Option_Entry "c" "command" "Use the given command instead of make. Options --target and --makefile are then ignored."
Add_Option_Entry "a" "add-allowed" "Specify additional allowed directories or files. Colon separated list."
Add_Option_Boolean "F" "no-sandbox" "Do not protect the installation with a sandbox."
Add_Option_Entry "e" "expand-sandbox" "By default, the sandbox is built relative to the current "\
"directory, '.'. Passing 1 to this option will build it relative to the parent directory, '..',"\
"passing 2 relative to '../..', and so on." ""
Add_Option_Boolean "l" "allow-leftovers" "When using UnionFS, do not return a failure code when it catches files outside the sandbox."

Parse_Options "$@"

Dir_Set Sandbox || Set_Boolean "no-sandbox"

if ! Boolean "no-sandbox"
then
   Is_Writable "$goboExecutables" || Verify_Superuser
fi

### Version ####################################################################

# TODO: this code is copy-and-pasted from SymlinkProgram.
# It should move into functions.

[ "$(Arg 2)" ] || Die "Argument missing: specify program and version."

unset unionsandbox

if ! Boolean "no-sandbox"
then
   if [ "$NO_UNIONFS" -o `cat $goboStatus/filesystems | grep unionfs |wc -l` = "0" ] 
   then
      Log_Terse "unionfs is unavailable.  Fallback to FiboSandbox!"
   else
      Log_Normal "unionfs is available.  Using UnionSandbox!"
      unionsandbox=yes
   fi
fi

package="`basename "$(Arg 1)" /`"
package="`GuessProgramCase "$(Arg 1)"`"
packageDir=`Get_Dir runtime "$package" ''`

if ! Is_Directory "$packageDir"
then Die "Directory $packageDir does not exist."
fi

installPackageDir=`Get_Dir install "$package" ''`
current="$packageDir/Current"

requested_version=$(Arg 2)
vdir=`Get_Dir runtime "$package" "$requested_version"`
if { ! Is_Directory "$vdir" ;} && { ! Boolean "no-sandbox" ;}
then Die "There is no version $requested_version for package $package."
fi
Dir_Set Current && [ "$version" != "$requested_version" ] && ln -sfn `basename "$vdir"` "$current"
version="$requested_version"

if Dir_Set Current && ! Exists "$current"
then
   youngestdir=`ls --sort=time "$packageDir" | head -n 1`
   ln -s "$youngestdir" "$current"
fi

### Install ####################################################################

function installation_failed() {
   # If not using UnionSandbox (including --no-sandbox" and rootless)
   # undo symlink from Settings to Defaults/Settings
   settings="$installPackageDir/Settings"
   if ! [ "$unionsandbox" ]
   then
      Is_Link "${settings}" && rm "${settings}"
      Is_Directory "${settings}.hold" && mv "${settings}.hold" "${settings}"
   fi
   Die "Installation failed."
}

Log_Normal "Installing $package..."

unset $expandsandbox
if Is_Entry "expand-sandbox"
then
   for i in $(seq $(Entry "expand-sandbox"))
   do
      expandsandbox=$expandsandbox/..
   done
fi

allowed=".$expandsandbox:$installPackageDir/$version:$packageDir/Settings:$packageDir/Variable"
Is_Entry "add-allowed" && allowed="$allowed:`Entry "add-allowed"`"
Log_Verbose "Sandbox: $allowed"

settings="$installPackageDir/Settings"
default_settings="$installPackageDir/$version/Resources/Defaults/Settings"
if [ "$unionsandbox" ] 
then
    sandbox_rw="$installPackageDir/$version/.SandboxInstall_Root"
    map_settings="--map ${default_settings}=${settings}"
    sandbox="UnionSandbox -w $sandbox_rw -s $allowed $map_settings -- "
else
    sandbox="FiboSandbox -s $allowed --"
fi

Boolean "no-sandbox" && sandbox=
[ "$ROOTLESS_GOBOLINUX" ] && sandbox=

# If not using UnionSandbox (including --no-sandbox" and rootless)
# symlink Settings to Defaults/Settings
if ! [ "$unionsandbox" ]
then
    Assert_Dir $default_settings
    Is_Directory "${settings}" && mv "${settings}" "${settings}.hold"
    ln -s "${default_settings}" "${settings}"
fi

eval `Args_To_Array args 3`

if Is_Entry "command"
then
   $sandbox `Entry "command"` "${args[@]}" || installation_failed
else
   $sandbox make -f "`Entry "makefile"`" "${args[@]}" "`Entry "target"`" || installation_failed
fi
result="$?"

if ! [ "$unionsandbox" ]
then
    Is_Link "${settings}" && rm "${settings}"
    Is_Directory "${settings}.hold" && mv "${settings}.hold" "${settings}"
fi

if [ "$unionsandbox" ]
then
   # Postprocess contents of $sandbox_rw here
   Log_Normal "Postprocessing Sandbox"
   Quiet pushd $sandbox_rw
   rm -f Programs/Glibc/Settings/ld.so.cache
   rm -rf System/Variable/tmp/{*,.*} &> /dev/null
   find -type d | xargs rmdir -p --ignore-fail-on-non-empty &> /dev/null
   Quiet popd
   leftovers=`(cd $sandbox_rw; find *) 2>/dev/null`
   [ "$leftovers" ] && {
      Log_Normal "Left over files:\n$leftovers"
      if ! Boolean "allow-leftovers"
      then exit 21 # Remember Fibo.
      fi
   }
   Quiet rmdir $sandbox_rw
fi

exit $result
