#!/bin/sh

# Changelog
#
# 08/12/2002 - [rafasgj] Removed RealPath
# 25/08/2002 - [hisham] Pager (-p) option
# 23/08/2002 - [hisham] Colored permissions
# 22/06/2002 - [hisham] fixed bug on paths starting with dot, such as ../a/b/c/hello
# 18/05/2002 - [hisham] can list multiple directories, fix hidden display
# 25/03/2002 - [hisham] mawk & devfs compatible
# XX/XX/XXXX - [hisham] first version, improvements

unset LANG
unset LC_ALL

ss=($(stty size))
ROWS=${ss[0]}
COLUMNS=${ss[1]}

SORT_OPTS="-s -k 1.1r,1.1r"

options=("$@")

while true
do
   [ "$1" ] || break
   case "$1" in
   --help)
      cat <<EOF
A pretty ls wrapper.

Usage:

    l [<options>...] <pattern>

-p, --pager
    Run the output through a pager, so you can scroll back on very long directories.
-t, --time
    Sort by time, most recent file shown last.
-s, --size
    Sort by size, largest size shown last.
-d, --directories
    List directories only.
-h, --hidden
    List dot-files only.
-a, --all
    List both regular and dot-files.
-L, --no-links
    List only files that are not symbolic links.

EOF
      exit 0
      ;;
   -p|--pager|--page)
      declare -a newoptions
      for (( i = 0, j = 0; i < ${#options[@]}; i++ ))
      do 
         if [ ${options[i]} != "-p" -a ${options[i]} != "--pager" -a ${options[i]} != "--page" ]
         then
            newoptions[j]=options[i]
            j=$[j+1]
         fi
      done
      "$0" "${newoptions[@]}" | less -r
      exit 0
      ;;
   -t|--time)
      export DIR_OPTS="$DIR_OPTS --sort=time -r "
      SORT_OPTS=" -m"
      shift
      ;;
   -s|--size)
      export DIR_OPTS="$DIR_OPTS --sort=size -r "
      SORT_OPTS=" -m"
      shift
      ;;
   -d|--directories)
      export DIRS_ONLY="yes"
      shift
      ;;
   -h|--hidden)
      export USE_HIDDEN=yes
      export DIR_OPTS="$DIR_OPTS -d .* "
      shift
      ;;
   -a|--all)
      export SHOW_ALL=yes
      shift
      ;;
   -L|--no-links)
      export SKIP_LINKS=yes
      shift
      ;;
   --)
      shift
      break
      ;;
   *)
      break
      ;;
   esac # esac is ridiculous.
done

export AWKPATH=".:/usr/share/awk:/usr/local/share/awk:/Programs/Gawk/Current/share/awk"

# Will not work when files from many directories are selected
DIR_NAME="$1"
[ "$DIR_NAME" ] || DIR_NAME="."
DIR_NAME=`readlink -f "$DIR_NAME"`
[ -d "$DIR_NAME" ] || DIR_NAME=`dirname $DIR_NAME 2> /dev/null`
if [ -z "$USE_HIDDEN" ]
then
    HIDDEN=`ls -Ad "$DIR_NAME"/.* 2> /dev/null | wc -l | awk '{ if ($1 -2 > 0) print "+" $1-2 }'`
fi
# 2> /dev/null

export USER=`id -un`

ls $DIR_OPTS -a --color=always -l "$@" |\
sort $SORT_OPTS |\
 awk -v dirname="$DIR_NAME" \
     -v hidden="$HIDDEN" \
     -v dirs_only="$DIRS_ONLY" \
     -v show_all="$SHOW_ALL" \
     -v skip_links="$SKIP_LINKS" \
     -v columns="$COLUMNS" \
     -f "group.awk" --source '
      function mega(inp      ,out,l) {
        l = length(inp)
        if (l>3) {
           out = "\033[22;39m" substr(inp,l-2)
           if (l>6) out = "\033[1;36m" substr(inp,1,l-6) "\033[22;36m" substr(inp,l-5,3) out
           else     out = "\033[22;36m" substr(inp,1,l-3) out
        } else out = inp
        if (l<9) out = substr("         ",1,9-l) out
        return out
      }

      BEGIN {
         grps = getgruser(ENVIRON["USER"])
         counter=0
         hiddenfiles=0
         subcounter=0
         subhidden=0
         subdir=0
         mes["Jan"]="01" ; mes["Feb"]="02" ; mes["Mar"]="03"
         mes["Apr"]="04" ; mes["May"]="05" ; mes["Jun"]="06"
         mes["Jul"]="07" ; mes["Aug"]="08" ; mes["Sep"]="09"
         mes["Oct"]="10" ; mes["Nov"]="11" ; mes["Dec"]="12"
         print ""
      }
      
      function decolorize(n) {
         gsub("\033.[0-9;]*m","",n)
         return n
      }
      
      function displaysubdir() {
         print  "                      ---------"
         printf "                      %s in %d", mega(subdir), subcounter
         if (subhidden > 0) {
            printf "\033[1;30m+%d\033[0m", subhidden
         }
         printf " file"
         if (subcounter+subhidden > 1) { printf "s" }
         printf "\n"
         print  ""
         total = total + subdir
         subcounter = 0
         subdir = 0
         subhidden = 0
      }

      /^.*:$/ {
         if (subdir > 0) {
            displaysubdir()
         }
         dirname=substr($0, 1, length($0)-1)
         dirname=decolorize(dirname)
         "readlink -f " dirname | getline readlink -f
         print "\033[1;33m" dirname "\033[22;39m"
      }

      ##### bloco principal #####
      /.[r-][w-][sx-].*$/ {
        simplename=decolorize($9)
        basename=gensub(".*/", "", "g", simplename)
      
        if (!(dirs_only=="yes" && substr($1,1,1) != "d")) {
        if (show_all=="yes" || (substr(basename,1,1) != ".")) {
        name=""
        ##### suporte a dev #####
        type = substr($1, 1, 1)
        type2 = substr($1, 6, 1)
        if (type == "b" || type == "c" || type2 == "b" || type2 == "c") {
           isdev = 1
           namestart = 10
           year = 9
        } else {
           isdev = 0
           namestart = 9
           year = 8
        }
        ##### monta nome de arquivo corrigindo espacos #####
        for (i=namestart;i<=NF;i++) {
          gsub("\\\\","",$(i))
          name = name $(i) " "
        }
        if (skip_links=="yes") {
          if (name ~ /.* -> .*/) {
            next
          }
        }
        ##### permissoes #####
        S1=decolorize($1)
        owner = substr(S1, 2, 3)
        group = substr(S1, 5, 3)
        all = substr(S1, 8, 3)
        if ($3 == ENVIRON["USER"]) {
           perm = owner "\033[1;30m" group all "\033[0m"
        } else if (" "$4" " ~ " "grps" ") {
           perm = "\033[1;30m" owner "\033[0m" group "\033[1;30m" all "\033[0m"
           useall = 0
        } else {
           perm = "\033[1;30m" owner group "\033[0m" all
        }
        ##### ajusta hora/ano #####
        if (length($(year))==4) $(year)=$(year)" "
        ##### exibe #####
        subdir = subdir + $5
        if (isdev) {
           printf "%.2d/%s %s %s  \033[1m%3d\033[0m:\033[1m%3d\033[0m", $8, mes[$7], $9, perm, $5, $6
        } else {
           printf "%.2d/%s %s %s%s", $7, mes[$6], $8, perm, mega($5)
        }
        printf " %s\033[0m\033[K\n", name
        counter++
        subcounter++
        } else {
        if (simplename != "." && simplename != "..") {
           hiddenfiles++
           subhidden++
        }
        }
        }
      }
      
      END {
        if (total > 0) {
           displaysubdir()
        } else {
           total = subdir
        }
        for (i = 0; i <= columns-2; i++) {
           printf "="
        }
        printf "\n"
#        print  "=============================================================================="
        printf "%s in %d", mega(total), counter
        if (hiddenfiles > 0) {
           printf "\033[1;30m+%d\033[0m", hiddenfiles
        }
        printf " file"
        if (counter+hiddenfiles > 1) { printf "s" }
        printf " - "
      }
   '
#awk
# Clean up ls options
           while true
      do case "$1" in
         -*) shift ;;
          *) break ;;
                 esac
                 done
# Ah... how artistic!

DF_USE="$DIR_NAME"
[ "$DF_USE" ] || DF_USE="."
df_line=`df "$DF_USE" 2> /dev/null | tail -n 1`
mount_point=`echo "$df_line" | cut -b 56-`" "
fsystem=`grep "^[^ ]*$mount_point" /proc/mounts | tail -n 1 | awk '{print $3}'`
#awk
echo -n "$fsystem: "
echo $df_line | 
   awk '

      function mega(inp ,out,l) {
        l = length(inp)
        if (l>3) {
           out = "\033[22;36m" substr(inp,l-2)
           if (l>6) out = "\033[1;37m" substr(inp,1,l-6) "\033[1;36m" substr(inp,l-5,3) out
           else     out = "\033[1;36m" substr(inp,1,l-3) out
        } else out = inp
#       if (l<7) out = substr("         ",1,7-l) out
        out = out "\033[22;39m"
        printf out
      }

      {
#       printf "%s: ", $1
        printf "%s", mega($(NF-3)); printf " kB used (%s), ", $(NF-1)
        printf "%s", mega($(NF-2));
        print " kB free"
      }
   ' 
#awk
