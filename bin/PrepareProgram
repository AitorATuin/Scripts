#!/bin/sh

### Imports ##############################################################

source ScriptFunctions
Import File
Import GoboLinux
Import Log
Import OptionParser
Import Directories
Import Array

### Options ##############################################################

helpOnNoArguments=yes
scriptDescription="prepares applications for instalation, running the 'configure' script."
scriptCredits="Copyright (C) 2001-2005 Hisham Muhammad - Released under the GNU GPL."
scriptUsage="<target_name> [<version_nr>] [ -- <additional_options> ]"
scriptExample="KDE 2.2"
scriptNotes="The directory hierarchy for the program is only created with --tree."

# This option should be removed; there's no more interaction in this script.
Add_Option_Boolean "b" "batch" "batch mode: no user interaction" 

Add_Option_Boolean "t" "tree" "Prepare directories only, do not attempt to run configure."
Add_Option_Boolean "T" "tree-cleanup" "Like --tree, but instead of creating directories, remove empty ones"
Add_Option_Boolean "k" "keep" "Keep the directory if it already exists in the directory hierarchy."
Add_Option_Boolean "r" "remove" "Remove the directory if it already exists in the directory hierarchy."
Add_Option_Entry   "c" "configure" "Specify program to be used as 'configure' script." "./configure"
Add_Option_Entry   "o" "configure-options" "Options that should be passed to configure."
Add_Option_Boolean "a" "autoconf" "Assume configure is based on autoconf, skipping detection."
Add_Option_Boolean "A" "no-autoconf" "Assume configure is NOT based on autoconf, skipping detection."
Add_Option_Boolean "D" "no-default-options" "Skip detection altogether, use only configure options passed on the command-line."

Parse_Options "$@"

Is_Entry "configure" && export PATH="$PATH:."

### Functions ############################################################

# TODO: this function is now in Compile and should probably disappear in the future
function config_is_autoconf() {
   Boolean "autoconf" && return 0
   Boolean "no-autoconf" && return 1
   grep -i "Generated .* autoconf" "$configureprogram" &> /dev/null
}

function config_accepts_prefix() {
   grep -- "--prefix" "$configureprogram" &> /dev/null
}

function build_change() {
   echo "/-L/!s/"$1"/"$2"/g;"
}

function color_command() {
   mtailrc=$1
   shift
   workaround=`Temporary_File`
   { "$@" 2>&1
     echo $? > $workaround
   } | mtail --config=${mtailrc} -q
   returnvalue=`cat $workaround`
   rm -- $workaround
   return $returnvalue
}

make_symlink() {
    local bname=`basename $1`
    Exists "${baseprogramdir}/${bname}" && ln -nsf "${baseprogramdir}/${bname}" "$1"
}

remove_symlink() {
    Exists `readlink -f $1` || rm -f -- "$1"
}

### Operation #############################################################

programname="$(Arg 1)"
[ -z "$programname" ] && Die "Missing argument."
Dir_Set Case && {
   # Respect capitalization passed, if any.
   if [ "$programname" = `echo "$programname" | tr '[:upper:]' '[:lower:]'` ]
   then programname=`GuessProgramCase "$1"`
   fi
}

if [ "$(Arg 2)" -a "$(Arg 2)" != "--" ]
then
   versionnumber="$(Arg 2)"
else
   versionnumber=`Which_Version "${goboPrograms}/${programname}/Current"`
   [ "$versionnumber" ] || Die "Please specify version."
fi

programname=`NamingConventions "$programname"`

baseprogramdir=`Get_Dir runtime "$programname" ''`
programdir=`Get_Dir runtime "$programname" "$versionnumber"`
settingsdir=`Get_Dir runtimeSettings "$programname" "$versionnumber"`
variabledir=`Get_Dir runtimeVariable "$programname" "$versionnumber"`

Dir_Set Install && installdir=`Get_Dir install "$programname" "$versionnumber"`

if Boolean "tree"
then
   Is_Writable `Get_Dir runtime '' ''` || Verify_Superuser
   Dir_Set Install && installdir=`Get_Dir install '' ''` || Verify_Superuser

   ask=yes
   unset keepdir
   Boolean "remove" && unset ask
   Boolean "keep" && { unset ask; keepdir=yes; }
   Boolean "batch" && unset ask

   if [ "$ask" -a -e "$programdir" ]
   then
      while true
      do
         Ask_Option "$programdir already exists. [r]emove, [k]eep, [C]ancel?" || exit 1
         case "$REPLY" in
         [Rr]) break ;;
         [Kk]) keepdir=yes; break ;;
         [Cc]) exit 1 ;;
         esac # esac is ridiculous.
      done
   fi

   if [ ! "$keepdir" ]
   then
      if [ -e "$programdir" ]
      then rm -rf -- "$programdir"
      fi
      if Dir_Set Install
      then
         Make_Directory `Get_Dir install "$programname"`
         Make_Directory "$installdir"
         Make_Directory "$baseprogramdir"
         ( cd "$baseprogramdir" ; ln -s "$installdir" "$versionnumber")
      fi
   fi

   if Dir_Set Shared
   then
      [ -L "$programdir/share" ]  && rm -- "$programdir/share"
      [ -d "$programdir/Shared" ] && ln -nsf "$programdir/Shared" "$programdir/share"
   fi

   dirop="Make_Directory"
   linkop="make_symlink"
elif Boolean "tree-cleanup"
then
   Is_Writable `Get_Dir runtime '' ''` || Verify_Superuser
   Dir_Set Install && `Get_Dir install '' ''` || Verify_Superuser

   dirop="Quiet rmdir -p"
   linkop="remove_symlink"
fi

if Boolean "tree" || Boolean "tree-cleanup"
then
   
   $dirop "$settingsdir"
   $dirop "$variabledir"
   $dirop "$programdir/Resources"
   $dirop "$programdir/Resources/Defaults/Settings"
   $dirop "$programdir/Resources/Daemons"
   $dirop "$programdir/Resources/Tasks"
   if Dir_Set Shared
   then $dirop "$programdir/Shared"
   else $dirop "$programdir/share"
   fi
   $dirop "$programdir/sbin"
   $dirop "$programdir/bin"
   $dirop "$programdir/lib"
   $dirop "$programdir/include"
   $dirop "$programdir/info"
   $dirop "$programdir/man"
   $dirop "$programdir/doc"
   $dirop "$programdir/libexec"
   $dirop "$programdir/man/man1"
   $dirop "$programdir/man/man2"
   $dirop "$programdir/man/man3"
   $dirop "$programdir/man/man4"
   $dirop "$programdir/man/man5"
   $dirop "$programdir/man/man6"
   $dirop "$programdir/man/man7"
   $dirop "$programdir/man/man8"
   $dirop "$programdir/man/man9"

   if Dir_Set Install
   then
      $linkop `Get_Dir installSettings "$programname" "$versionnumber"`
      $linkop `Get_Dir installVariable "$programname" "$versionnumber"`
   fi

   if Dir_Set Shared
   then
      if Boolean "tree"
      then
         [ -L "$programdir/share" ] && rm -- "$programdir/share"
         ln -nfs "$programdir/Shared" "$programdir/share"
      else
         Is_Real_Directory "$programdir/Shared" || Quiet rm -- "$programdir/share"
      fi
   fi

   if Boolean "tree" && Dir_Set Current
   then
      rm -f -- "$baseprogramdir/Current"
      ( cd "$baseprogramdir" ; ln -s "$versionnumber" "Current" )
   fi

   exit 0
fi

configureprogram=`Entry "configure"`

echo
Log_Normal "Preparing..."
rm -f config.cache

Exists "$configureprogram" || Die "configure script "`[ $configureprogram != "./configure" ] && echo " ($configureprogram) "`"not found."

if Boolean "no-default-options"
then
   configure_options=()
elif config_is_autoconf
then
   Log_Normal "Autoconf configure script detected."
   configure_options=(
      --prefix="$programdir"
      --sysconfdir="$settingsdir"
      --localstatedir="$variabledir"
   )
   if [ "$goboCrossCompiling" = "yes" ]
   then
      configure_options=(
         "${configure_options[@]}"
         --build=$cross_configure_build
         --host=$cross_configure_host
         --cache-file=$cross_cache_file
         --x-includes=$goboHeaders
         --x-libraries=$goboLibraries
      )
      cp -f ${goboSettings}/Compile/Cross/$cross_cache_file .
   fi
elif config_accepts_prefix
then
   Log_Normal "Non-autoconf configure script detected (accepts --prefix)."
   configure_options=(
      --prefix="$programdir"
   )
else
   configure_options=()
fi

configure_options=(${configure_options[@]} `Entry configure-options`)

color_command "`Find_Conf configure.mtailrc`" \
  "$configureprogram" "${configure_options[@]}" >&$normalFD || Die "configure failed."

exit 0
