#!/bin/sh

source ScriptFunctions
Import File
Import GoboLinux
Import Log
Import OptionParser
Import Process
Import String
Import Array

### Defines ###################################################################

deps_file="Resources/Dependencies"

### Options ###################################################################

scriptDescription="Queries dependencies in a GoboLinux package."
scriptCredits="Released under the GNU GPL."
helpOnNoArguments=yes
scriptUsage="{ [-c] <package> [<version>] | -f <file> }"
scriptNotes="If no version is specified, Current is assumed. "
Add_Option_Boolean "f" "file" "show dependencies of one file only."
Add_Option_Boolean "c" "check" "check the package's dependency file,\
 instead of generating one."
Add_Option_Boolean "r" "reverse" "reverse dependency match: indicate who uses a given program."
Add_Option_Entry   "C" "cross-compile" "lets GoboPath export directories based on \$crossPrefixDir."
Add_Option_Boolean "a" "all" "inspect all files, not only those in 'bin', 'sbin' and 'lib'."
Add_Option_Boolean "m" "missing-only" "Display missing dependencies only. (check mode only)"
Add_Option_Boolean "H" "higher-or-missing-only" "Display missing dependencies or higher versions only. (check mode only)"
Add_Option_Boolean "l" "list" "List dependency file, if any (generate if not present)."
Add_Option_Boolean "d" "dependencies-file" "Do not look at parses the passed file."
Add_Option_Entry   "e" "execute" "Execute the command on each missing/higher. (check mode only)" ""
Add_Option_Boolean "b" "batch" "Batch mode: avoid asking questions."
Add_Option_Entry   "p" "programs" "<dir> to check dependencies against."
Add_Option_Boolean "w" "write" "Write dependencies to $deps_file."

Parse_Options "$@"
shift $parsedArguments

if Is_Entry "cross-compile"
then
   arch=`Entry "cross-compile"`
   crossCompile="--cross-compile $arch"
   . GoboPath Reload
fi

### Utility functions #################################################################

function extract_dependencies_from_file() {
if Is_Entry "cross-compile"
then
   readelf_result=`${crossCompiler}readelf -a "$1" 2> /dev/null | grep "Shared library" | cut -d"[" -f2 | cut -d"]" -f1`
   for i in $readelf_result
   do
      if [ ! -h $goboLibraries/$i ]
      then
         echo "# *Warning*: Unresolved library $i"
      else
        readlink -f "$goboLibraries/$i" | sed "s%$crossPrefixDir%%g"
      fi
   done
else
   lddresult=`ldd "$1" 2> /dev/null | grep "=>"`
   echo -n "$lddresult"  | grep "not found" | awk '{ print $1 }' | while read i
   do
      echo "# *Warning*: Unresolved library $i"
   done

   echo -n "$lddresult"  | grep -v "not found" | awk '{ print $3 }' | while read i
   do
      if [ ! "$i" ]
      then
         echo "here" "->" "$lddresult"
      fi
      readlink -f "$i"
   done
fi
}

function path2programs() {
#   sed 's@/Programs/\([^/]*\)/\([^/]*\)/.*$@\1 \2@g'
# The follow perl could/should be converted to sed.  Unfortunately I don't know sed.
   perl -n -e '$_ =~ m@/([^/]+)/([^/]+)/lib@ && print "$1 $2\n";' \
           -e '$_ =~ m@/([^/]+)/([^/]+)/libexec@ && print "$1 $2\n";' \
           -e '$_ =~ m@/([^/]+)/([^/]+)/bin@ && print "$1 $2\n";' \
           -e '$_ =~ m@/([^/]+)/([^/]+)/sbin@ && print "$1 $2\n";' \
           -e '$_ =~ m@([# ]+.*)@ && print "$1 $2 $3 $4\n";'
}

### --file: Check one file only #########################################################

if Boolean "file"
then
   extract_dependencies_from_file "$1"
   exit 0
fi


### Parse options #######################################################################
# 
if ! Boolean "dependencies-file"
then
   package=`GuessProgramCase $1 $2`
   if [ "$2" ]
   then
      version=`Get_Version "$package" "$2"`
   else
      version=`Get_Version "$package" "Current"`
   fi
   prefix=`readlink -f $goboPrograms/$package/$version`
fi

execute=`Entry "execute"`

if [ "$execute" ] && [ "`basename $execute`" = "Compile" ]
then execute="$execute $crossCompile"
fi


### --reverse: Reverse dependency match #################################################

if Boolean "reverse"
then
   for f in "${goboPrograms}"/*/*/Resources/Dependencies
   do
      echo "$f" | grep -q "/Current/" && continue
      if [ "$2" ]
      then grep -qi "^$package $version" "$f"
      else grep -qi "^$package " "$f"
      fi
      if Succeeded
      then echo `Which_Package "$f"` `Which_Version "$f"`
      fi
   done
   exit 0
fi



if Boolean "dependencies-file"
then
   dependenciesfile="$1"
   [ -f "$dependenciesfile" ] || Die "File $dependenciesfile not found."
   #echo $dependenciesfile
else
   Is_Directory "$goboPrograms/$package" || Die "Package $package does not exist."
   Is_Empty "$version" && Die "Couldn't find a proper version for $package."
   Is_Directory "$prefix" || Die "$package version $version is not a valid package."
   dependenciesfile=`Dependencies_File "$package" "$version"`
fi


### --list: Print dependencies ##########################################################

if Boolean "list"
then
   if [ "$dependenciesfile" ]
   then
      cat "$dependenciesfile"
      exit 0
   fi
fi

### --check: Verify dependencies ########################################################
if Boolean "check"
then

   function ask_install_or_skip() {
      Ask_Option "Install $program $version or skip this dependency? [I]nstall/[S]kip/[IA]Install All/[SA]Skip All"
      case "$REPLY" in
      I|i)
         case `Get_Token "$execute" "/" "-1"` in
         Compile)
           String_To_Array available_versions "`FindPackage $noweb --full-list --type=recipe "$program" 2> /dev/null`" ;;
         InstallPackage)
           String_To_Array available_versions "`FindPackage $noweb --full-list --type=o "$program" 2> /dev/null`" ;;
         esac # hmm...
         if [ "$available_versions" ]
         then
           latest_version=`Parse_Version "${available_versions[0]}"`
           if [ `GuessLatest $latest_version $version` != $version ]
           then
               Log_Question "There's a later version of $program available ($latest_version)."
               Ask_Option "Do you want to install the latest version instead? [Y]es/[N]o/[L]ist available versions/[C]ancel"
               case "$REPLY" in
               Y|y)
                   version=$latest_version ;;
               L|l)
                   i=0
                   total=0
                   for v in $available_versions
                   do
                       alt_version=`Parse_Version $v`
                       Log_Normal "$i) $alt_version"
                       order[$i]=$total
                       i=`expr $i + 1`
                   done
                   Ask_Option "Enter corresponding number for version you want to install"
                   version=`Parse_Version "${available_versions[${order[$REPLY]}]}"` ;;
               C|c)
                   exit ;;
               esac
           fi
         fi
         programs_to_install=("${programs_to_install[@]}" "$program $version" ) ;;
      SA|sa)
         skipall=1 ;;
      IA|ia)
         installall=1
         programs_to_install=("${programs_to_install[@]}" "$program $version" ) ;;
      esac # hmm... exactly what you're thinking.
   }

   installall=
   [ `Boolean "batch"` ] && installall=1 && batch="--batch"
   skipall=

   check_programs=`Entry "programs"`
   ! [ "$check_programs" = "" ] && export goboPrograms="$check_programs"

   [ -f "$dependenciesfile" ] || Die "Dependencies file for $package version $version not found."
   result=0

   for i in `grep -v "^#" "$dependenciesfile" | grep -v "^\\*" | grep -v "^$" | tr -- " \n" "@ "`
   do
      program=`echo "$i" | cut -d"@" -f1`
      version=`echo "$i" | cut -d"@" -f2`
      if Ends_With "CVS" "$version"
      then
         version="CVS"
      fi
      iprogram=`GuessProgramCase $program $version`
      if [ ! -d "$goboPrograms/$iprogram" ] # program not found
      then
         # Look for the existance of a compatible package
         compatible_package=`HasCompatiblePackage $program`
         if [ "$compatible_package" != "" ]
         then
            Log_Normal "Dependency $program is not installed, but compatible package $compatible_package is"
            continue
         fi
         result=1
         if [ "$installall" ]
         then
            Log_Terse "Dependency $program $version is not installed."
            programs_to_install=("${programs_to_install[@]}" "$program $version" )
         elif [ "$execute" -a ! "$skipall" ] 
         then
            Log_Question "Dependency $program $version is not installed."
            ask_install_or_skip
         fi
      else #program found
         if ! Boolean "missing-only"
         then
            if Is_Directory "${goboPrograms}/$iprogram/$version"
            then
               Log_Verbose "OK ---------------> $program $version"
            
            else # program found, but version not installed
               yourversion= #`Get_Version "$iprogram" "Current"`
               [ "$yourversion" ] || yourversion=`GuessLatest \`ls /Programs/$iprogram |grep -v Settings |grep -v Variable |grep -v Current\``
               
               if [ "`GuessLatest $version $yourversion`" == "$yourversion" ]
               then # a newer version is already installed
                  if ! Boolean "higher-or-missing-only"
                  then
                     Log_Normal "Dependency $program is installed, but version differs (required $version, yours is $yourversion)"
                  fi
               else # an older version is installed
                  result=1
                  if [ "$execute" -a ! "$skipall" -a ! "$installall" ] 
                  then
                     Log_Question "Dependency $program is installed, but required version is higher ($version, yours is $yourversion)"
                     ask_install_or_skip
                  else 
                     Log_Terse "Dependency $program is installed, but version differs (required $version, yours is $yourversion)"
                     [ "$installall" ] && programs_to_install=("${programs_to_install[@]}" "$program $version" )
                  fi
               fi
            fi
         fi
      fi
   done
   for p in "${programs_to_install[@]}"
   do
       $execute $batch $p || $execute $batch `echo $p | sed s/'\(.*\)\ .*'/'\1'/`
   done
   exit $result
fi

### default: Generate a dependency report ###############################################
if Boolean "write"
then
   $sudo_validate
   writer="$sudo_exec tee $prefix/$deps_file"
else
   writer="cat"
fi

blacklistfile=`Find_Conf "Dependencies.blacklist"`
blacklist=("do_not_match")
if [ "$blacklistfile" ]
then
   for app in `cat "$blacklistfile"`
   do blacklist=("${blacklist[@]}" "^$app ")
   done
fi

if [ "$prefix" ]
then
{
   Progress_Start "Generating dependency report. Please wait: "
   {
      if Boolean "all"
      then
         find "$prefix"
      else
         find "$prefix" -path "$prefix/sbin/*" -or \
                        -path "$prefix/bin/*"  -or \
                        -path "$prefix/lib/*"  -or \
                        -path "$prefix/libexec/*"
      fi
   } | while read i
   do
      if [ -x "$i" -a ! -L "$i" -a ! -d "$i" ]
      then
         extract_dependencies_from_file "$i"
      fi
      Progress_Move
   done
   Progress_End
} | path2programs | sort | uniq | grep -v "^$package " | FilterLines -n "${blacklist[@]}" | $writer
fi
