#!/bin/sh

source ScriptFunctions
Import File
Import GoboLinux
Import Log
Import OptionParser
Import Process
Import String

### Changelog #################################################################

# 12/09/2005 - [lucasvr] getting dependencies for cross-compiled apps through readelf
# 31/08/2005 - [lucasvr] passing cross-compile flags to child Compile processes
# 15/12/2004 - [lucasvr] integrated with Compile's cross-compiling feature
# 04/12/2004 - [hisham] circumvent CVS snapshot dependencies
# 24/11/2004 - [hisham] support for a Dependencies.blacklist conf file
# 12/11/2004 - [hisham] bugfix: disambiguate -h option
# 12/11/2004 - [calica] - --write option
# 03/09/2004 - [detsch] - using GuessProgramCase instead of 'find -i' to detect 
#                         installed program
# 23/08/2004 - [detsch] - major changes on 'check' mode. Instead of just printing, 
#                         a command can be executed (like Compile or InstallPackage)
#            - 'execute' option
#            - 'higher-or-missing-only' option -> using GuessLatest
#            - 'dependencies-file' option
#            
# 23/06/2004 - [calica] clean up $prefix to handle symlinks
#              Changed how the paths are converted to program/version.  Keying off of
#              \1/\2/[bin|sbin|lib|libexec rather than Programs/\1/\2
# 10/06/2004 - [calica] Use "GuessProgramCase" to remove case sensitivity
# 27/04/2004 - [hisham] -c now returns exit code 1 when there's a program missing
# 08/12/2003 - [rafasgj] Removed RealPath
#            - [hisham] Commented out Python dependencies
# 14/10/2003 - [detsch,gbedin] fixed extract_dependencies for
#              libraries within subdirectories of ${goboLibraries}
# 05/07/2003 - [hisham] Added "list" switch
# 26/06/2003 - [calica] Added Checking for Daemons
# 31/05/2002 - [hisham] Fixed listing of files searched
# 26/05/2002 - [hisham] Added "all" switch
# 12/05/2002 - [hisham] First version


### Defines ###################################################################

deps_file="Resources/Dependencies"

### Options ###################################################################

scriptDescription="Queries dependencies in a GoboLinux package."
scriptCredits="Released under the GNU GPL."
helpOnNoArguments=yes
scriptUsage="{ [-c] <package> [<version>] | -f <file> }"
scriptNotes="If no version is specified, Current is assumed. "
Add_Option_Boolean "f" "file" "show dependencies of one file only."
Add_Option_Boolean "c" "check" "check the package's dependency file,\
 instead of generating one."
Add_Option_Boolean "r" "reverse" "reverse dependency match: indicate who uses a given program."
Add_Option_Entry   "C" "cross-compile" "lets GoboPath export directories based on \$crossPrefixDir."
Add_Option_Boolean "a" "all" "inspect all files, not only those in 'bin', 'sbin' and 'lib'."
Add_Option_Boolean "m" "missing-only" "Display missing dependencies only. (check mode only)"
Add_Option_Boolean "H" "higher-or-missing-only" "Display missing dependencies or higher versions only. (check mode only)"
Add_Option_Boolean "l" "list" "List dependency file, if any (generate if not present)."
Add_Option_Boolean "d" "dependencies-file" "Do not look at parses the passed file."
Add_Option_Entry   "e" "execute" "Execute the command on each missing/higher. (check mode only)" ""
Add_Option_Boolean "b" "batch" "Batch mode: avoid asking questions."
Add_Option_Entry   "p" "programs" "<dir> to check dependencies against."
Add_Option_Boolean "w" "write" "Write dependencies to $deps_file."

Parse_Options "$@"
shift $parsedArguments

if Is_Entry "cross-compile"
then
   arch=`Entry "cross-compile"`
   crossCompile="--cross-compile $arch"
   . GoboPath Reload
fi

### Utility functions #################################################################

function extract_dependencies_from_file() {
if Is_Entry "cross-compile"
then
   readelf_result=`${crossCompiler}readelf -a "$1" 2> /dev/null | grep "Shared library" | cut -d"[" -f2 | cut -d"]" -f1`
   for i in $readelf_result
   do
      if [ ! -h $goboLibraries/$i ]
      then
         echo "# *Warning*: Unresolved library $i"
      else
        readlink -f "$goboLibraries/$i" | sed "s%$crossPrefixDir%%g"
      fi
   done
else
   lddresult=`ldd "$1" 2> /dev/null | grep "=>"`
   echo -n "$lddresult"  | grep "not found" | awk '{ print $1 }' | while read i
   do
      echo "# *Warning*: Unresolved library $i"
   done

   echo -n "$lddresult"  | grep -v "not found" | awk '{ print $3 }' | while read i
   do
      if [ ! "$i" ]
      then
         echo "here" "->" "$lddresult"
      fi
      readlink -f "$i"
   done
fi
}

function path2programs() {
#   sed 's@/Programs/\([^/]*\)/\([^/]*\)/.*$@\1 \2@g'
# The follow perl could/should be converted to sed.  Unfortunately I don't know sed.
   perl -n -e '$_ =~ m@/([^/]+)/([^/]+)/lib@ && print "$1 $2\n";' \
           -e '$_ =~ m@/([^/]+)/([^/]+)/libexec@ && print "$1 $2\n";' \
           -e '$_ =~ m@/([^/]+)/([^/]+)/bin@ && print "$1 $2\n";' \
           -e '$_ =~ m@/([^/]+)/([^/]+)/sbin@ && print "$1 $2\n";' \
           -e '$_ =~ m@([# ]+.*)@ && print "$1 $2 $3 $4\n";'
}

function execute_program {
   $execute $batch "$1" "$2" || $execute $batch "$1"
}

### --file: Check one file only #########################################################

if Boolean "file"
then
   extract_dependencies_from_file "$1"
   exit 0
fi


### Parse options #######################################################################
# 
package=`GuessProgramCase $1 $2`
if [ "$2" ]
then
   version=`Get_Version "$package" "$2"`
else
   version=`Get_Version "$package" "Current"`
fi

execute=`Entry "execute"`
prefix=`readlink -f $goboPrograms/$package/$version`

if [ "$execute" ] && [ "`basename $execute`" = "Compile" ]
then execute="$execute $crossCompile"
fi


### --reverse: Reverse dependency match #################################################

if Boolean "reverse"
then
   for f in "${goboPrograms}"/*/*/Resources/Dependencies
   do
      echo "$f" | grep -q "/Current/" && continue
      if [ "$2" ]
      then grep -qi "^$package $version" "$f"
      else grep -qi "^$package " "$f"
      fi
      if Succeeded
      then echo `Which_Package "$f"` `Which_Version "$f"`
      fi
   done
   exit 0
fi



if Boolean "dependencies-file"
then
   dependenciesfile="$1"
   [ -f "$dependenciesfile" ] || Die "File $dependenciesfile not found."
   #echo $dependenciesfile
else
   Is_Directory "$goboPrograms/$package" || Die "Package $package does not exist."
   Is_Empty "$version" && Die "Couldn't find a proper version for $package."
   Is_Directory "$prefix" || Die "$package version $version is not a valid package."
   dependenciesfile=`Dependencies_File "$package" "$version"`
fi


### --list: Print dependencies ##########################################################

if Boolean "list"
then
   if [ "$dependenciesfile" ]
   then
      cat "$dependenciesfile"
      exit 0
   fi
fi

### --check: Verify dependencies ########################################################
if Boolean "check"
then
   installall=
   [ `Boolean "batch"` ] && installall=1 && batch="--batch"
   skipall=

   check_programs=`Entry "programs"`
   ! [ "$check_programs" = "" ] && export goboPrograms="$check_programs"

   [ -f "$dependenciesfile" ] || Die "Dependencies file for $package version $version not found."
   result=0

   for i in `grep -v "^#" "$dependenciesfile" | grep -v "^\\*" | grep -v "^$" | tr -- " \n" "@ "`
   do
      program=`echo "$i" | cut -d"@" -f1`
      version=`echo "$i" | cut -d"@" -f2`
      if Ends_With "CVS" "$version"
      then
         version="CVS"
      fi
      iprogram=`GuessProgramCase $program $version`
      if [ ! -d "$goboPrograms/$iprogram" ] # program not found
      then
         # Look for the existance of a compatible package
         compatible_package=`HasCompatiblePackage $program`
         if [ "$compatible_package" != "" ]
         then
            Log_Normal "Dependency $program is not installed, but compatible package $compatible_package is"
            continue
         fi
         result=1
         if [ "$installall" ]
         then
            Log_Terse "Dependency $program $version is not installed."
            execute_program "$program" "$version"
         elif [ "$execute" -a ! "$skipall" ] 
         then
            Log_Question "Dependency $program $version is not installed."
            Ask_Option "Install $program $version or skip this dependency? [I]nstall/[S]kip/[IA]Install All/[SA]Skip All"
            case "$REPLY" in
            I|i)
               execute_program "$program" "$version" ;;
            SA|sa)
               skipall=1 ;;
            ia|ia)
               installall=1
               execute_program "$program" "$version" ;;
            esac # esac is ridiculous.
         fi
      else #program found
         if ! Boolean "missing-only"
         then
            if Is_Directory "${goboPrograms}/$iprogram/$version"
            then
               Log_Verbose "OK ---------------> $program $version"
            
            else # program found, but version not installed
               yourversion=`Get_Version "$iprogram" "Current"`
               [ "$yourversion" ] || yourversion=`GuessLatest \`ls /Programs/$iprogram |grep -v Settings |grep -v Variable |grep -v Current\`` 
               
               if [ "`GuessLatest $version $yourversion`" == "$yourversion" ]
               then # a newer version is already installed
                  if ! Boolean "higher-or-missing-only"
                  then
                     Log_Normal "Dependency $program is installed, but version differs (required $version, yours is $yourversion)"
                  fi
               else # an older version is installed
                  result=1
                  if [ "$execute" -a ! "$skipall" -a ! "$installall" ] 
                  then
                     Log_Question "Dependency $program is installed, but required version is higher ($version, yours is $yourversion)"
                     Ask_Option "Install $program $version or skip this dependency? [I]nstall/[S]kip/[IA]Install All/[SA]Skip All"
                     [ "$REPLY" = "I" -o "$REPLY" = "i" ] && { $execute "$program" "$version" || $execute "$program" ;}
                     [ "$REPLY" = "SA" -o "$REPLY" = "sa" ] && skipall=1
                     [ "$REPLY" = "IA" -o "$REPLY" = "ia" ] && installall=1 && { $execute "$program" "$version" || $execute "$program" ;}
                  else 
                     Log_Terse "Dependency $program is installed, but version differs (required $version, yours is $yourversion)"
                     [ "$installall" ] && { $execute "$program" "$version" || $execute "$program" ;}
                  fi
               fi
            fi
         fi
      fi
   done 
   exit $result
fi

### default: Generate a dependency report ###############################################
if Boolean "write"
then
   $sudo_validate
   writer="$sudo_exec tee $prefix/$deps_file"
else
   writer="cat"
fi

blacklistfile=`Find_Conf "Dependencies.blacklist"`
blacklist=("do_not_match")
if [ "$blacklistfile" ]
then
   for app in `cat "$blacklistfile"`
   do blacklist=("${blacklist[@]}" "^$app ")
   done
fi

if [ "$prefix" ]
then
{
   Progress_Start "Generating dependency report. Please wait: "
   {
      if Boolean "all"
      then
         find "$prefix"
      else
         find "$prefix" -path "$prefix/sbin/*" -or \
                        -path "$prefix/bin/*"  -or \
                        -path "$prefix/lib/*"  -or \
                        -path "$prefix/libexec/*"
      fi
   } | while read i
   do
      if [ -x "$i" -a ! -L "$i" -a ! -d "$i" ]
      then
         extract_dependencies_from_file "$i"
      fi
      Progress_Move
   done
   Progress_End
} | path2programs | sort | uniq | grep -v "^$package " | FilterLines -n "${blacklist[@]}" | $writer
fi
