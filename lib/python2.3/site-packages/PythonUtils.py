#!/bin/env python

import os, sys

def getGoboVariable(name, filename = 'GoboPath', isList = False) :
	
	if filename != 'GoboPath' :
		goboSettings = getGoboVariable('goboSettings')
		goboPrograms = getGoboVariable('goboPrograms')
		goboScriptsDefaults = goboPrograms+'/Scripts/Current/Resources/Defaults/Settings/'
		goboManagerDefaults = goboPrograms+'/Manager/Current/Resources/Defaults/Settings/'
		files = [ "~/.Settings/"+filename, goboSettings + "/"+filename, goboScriptsDefaults + "/"+filename, goboManagerDefaults+"/"+filename, filename]
	else :
		files = [ filename]
	
	if not isList :
		try :
			return os.environ[name]
		except :
			for file in files :
				value = os.popen('. '+file+' 2> /dev/null; echo -n $'+name).read()
				if value :
					break
			os.environ[name] = value
			return value
	else :
		try :
			return os.environ[name].split()
		except :
			for file in files :
				os.environ[name] = os.popen("/bin/sh -c '. " + file +" 2> /dev/null; echo -n $"+name+"'").read()
				if os.environ[name] :
					break
			return os.environ[name].split()
			
	
def getCompileOptions() :
	import os
	
	goboSettings = getGoboVariable('goboSettings')
	goboPrograms = getGoboVariable('goboPrograms')
	goboCompileDefaults = goboPrograms+'/Compile/Current/Resources/Defaults/Settings/'
	compileSettingsFiles = [ "~/.Settings/Compile/Compile.conf", goboSettings + "/Compile/Compile.conf",  goboCompileDefaults+"/Compile/Compile.conf" ]
	
	try :
		compileRecipeDirs = os.environ['compileRecipeDirs'].split()
	except :
		for file in compileSettingsFiles :
			compileRecipeDirs = os.popen("/bin/sh -c '. " +file+" 2> /dev/null; for i in ${compileRecipeDirs[@]}; do echo $i; done'").readlines()
			if compileRecipeDirs :
				break
	
	try :
		getRecipeStores = os.environ['getRecipeStores'].split()
	except :
		for file in compileSettingsFiles :
			getRecipeStores = os.popen("/bin/sh -c '. " + file +" 2> /dev/null; for i in ${getRecipeStores[@]}; do echo $i; done'").readlines()
			if getRecipeStores :
				break
				
	import os.path
	return (map(os.path.expanduser,compileRecipeDirs), getRecipeStores)
	
currentString = ''
def consoleProgressHook(label, i = 0, n = 0, showWhenChanged = False) :
	global spin
	global currentString

	if not label :
	    sys.stderr.write('\n')
	    return
	    
	if label != currentString :
		if currentString :
			sys.stderr.write('\n')
		sys.stderr.write(label+'...  ')
		currentString = label
	
	if i >= n :
		sys.stderr.write('\n')
		currentString = ''
		return
	
	if  i % 4 == 0 :
		sys.stderr.write('\b|')
	elif i % 4 == 1 :
		sys.stderr.write('\b/')
	elif i % 4 == 2 :
		sys.stderr.write('\b-')
	elif i % 4 == 3 :
		sys.stderr.write('\b\\')

def caseinsensitive_sort(stringList):
    """case-insensitive string comparison sort
    doesn't do locale-specific compare
    though that would be a nice addition
    usage: stringList = caseinsensitive_sort(stringList)"""

    tupleList = [(x.lower(), x) for x in stringList]
    tupleList.sort()
    return [x[1] for x in tupleList]

class KeyInsensitiveDict:
    """Dictionary, that has case-insensitive keys.

    Keys are retained in their original form
    when queried with .keys() or .items().

    Implementation: An internal dictionary maps lowercase
    keys to (key,value) pairs. All key lookups are done
    against the lowercase keys, but all methods that expose
    keys to the user retrieve the original keys."""

    def __init__(self, dict=None):
        """Create an empty dictionary, or update from 'dict'."""
        self._dict = {}
        if dict:
            self.update(dict)

    def __getitem__(self, key):
        """Retrieve the value associated with 'key' (in any case)."""
        k = key.lower()
        return self._dict[k][1]

    def __setitem__(self, key, value):
        """Associate 'value' with 'key'. If 'key' already exists, but
        in different case, it will be replaced."""
        k = key.lower()
        self._dict[k] = (key, value)

    def has_key(self, key):
        """Case insensitive test wether 'key' exists."""
        k = key.lower()
        return self._dict.has_key(k)

    def keys(self):
        """List of keys in their original case."""
        return [v[0] for v in self._dict.values()]

    def values(self):
        """List of values."""
        return [v[1] for v in self._dict.values()]

    def items(self):
        """List of (key,value) pairs."""
        return self._dict.values()

    def get(self, key, default=None):
        """Retrieve value associated with 'key' or return default value
        if 'key' doesn't exist."""
        try:
            return self[key]
        except KeyError:
            return default

    def setdefault(self, key, default):
        """If 'key' doesn't exists, associate it with the 'default' value.
        Return value associated with 'key'."""
        if not self.has_key(key):
            self[key] = default
        return self[key]

    def update(self, dict):
        """Copy (key,value) pairs from 'dict'."""
        for k,v in dict.items():
            self[k] = v

    def __repr__(self):
        """String representation of the dictionary."""
        items = ", ".join([("%r: %r" % (k,v)) for k,v in self.items()])
        return "{%s}" % items

    def __str__(self):
        """String representation of the dictionary."""
        return repr(self)

class TextHarvester :
	def __init__(self, data, stripTags = False) :
		self.c = 0
		self.data = data
		self.stripTags = stripTags

	def skipUntilNext(self, s) :
		self.c = self.data.index(s,self.c) + len(s)
	
	def getUntilNext(self, s) :
		begin = self.c
		end = self.data.index(s, begin)
		self.c = end 
		if self.stripTags :
			return self.doStripTags(self.data[begin:end])
		else :
			return self.data[begin:end]
	
	def getUntilEnd(self) :
		x = self.data[self.c:]
		self.c = len(self.data)
		return x
		
	def contains(self, s) :
		return self.data.find(s, self.c) > -1

	def getLinesUntil(self, s) :
		begin = self.c
		end = self.data.index(s, begin)
		self.c = end
		if self.stripTags :
			return self.doStripTags(self.data[begin:end].split('\n'))
		else :
			return self.data[begin:end].split('\n')
			
	def doStripTags(self, s) :
		while True :
			beg = s.find('<') 
			end = s.find('>') 
			#print beg, end
			if beg > -1 and end > -1 and beg < end:
				s1 = s[:beg]
				s2 = s[end+1:]
				s = s1 + s2
			else :
				return s